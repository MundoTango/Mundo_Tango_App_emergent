/**
 * Mundo Tango ESA LIFE CEO - Layer 52 Agent: Documentation System
 * Expert agent responsible for API docs, user guides, and comprehensive documentation
 * 
 * ENHANCED: File Integrity Protection (Layer 3)
 * - Real-time monitoring of critical files
 * - Alert on missing files
 * - Integration with pre-deploy checks
 */

import { EventEmitter } from 'events';
import { existsSync, readFileSync } from 'fs';
import { join } from 'path';

export interface DocumentationFile {
  path: string;
  type: 'api' | 'user-guide' | 'technical' | 'readme' | 'changelog' | 'tutorial';
  format: 'markdown' | 'html' | 'pdf' | 'json' | 'yaml';
  lastUpdated: Date;
  wordCount: number;
  completeness: number; // 0-100%
  readability: number; // 0-100%
}

export interface APIDocumentation {
  endpoints: number;
  documented: number;
  examples: number;
  schemas: number;
  interactivity: boolean;
  framework: string;
}

export interface FileIntegrityStatus {
  enabled: boolean;
  lastCheck: Date | null;
  totalCriticalFiles: number;
  missingFiles: string[];
  integrity: number; // 0-100%
  alerts: string[];
}

export interface DocumentationSystemStatus {
  fileIntegrity: FileIntegrityStatus;
  apiDocumentation: {
    swagger: boolean;
    openapi: boolean;
    postman: boolean;
    insomnia: boolean;
    interactive: boolean;
    autoGenerated: boolean;
    coverage: number;
    score: number;
  };
  userDocumentation: {
    userGuides: boolean;
    tutorials: boolean;
    gettingStarted: boolean;
    faq: boolean;
    troubleshooting: boolean;
    videoTutorials: boolean;
    score: number;
  };
  technicalDocumentation: {
    architecture: boolean;
    deployment: boolean;
    configuration: boolean;
    development: boolean;
    codeComments: boolean;
    changelog: boolean;
    score: number;
  };
  documentationMaintenance: {
    versionControl: boolean;
    automatedUpdates: boolean;
    reviewProcess: boolean;
    linkValidation: boolean;
    contentFreshness: number;
    multiLanguage: boolean;
    score: number;
  };
  accessibility: {
    screenReaderFriendly: boolean;
    keyboardNavigation: boolean;
    highContrast: boolean;
    searchFunctionality: boolean;
    mobileOptimized: boolean;
    offlineAccess: boolean;
    score: number;
  };
  analytics: {
    usageTracking: boolean;
    popularContent: boolean;
    searchAnalytics: boolean;
    userFeedback: boolean;
    performanceMetrics: boolean;
    contentGaps: boolean;
    score: number;
  };
  files: DocumentationFile[];
  apiDocs: APIDocumentation;
  overallMetrics: {
    totalFiles: number;
    totalWords: number;
    averageCompleteness: number;
    averageReadability: number;
    lastUpdateAge: number; // days
  };
  compliance: {
    layerCompliance: number;
    criticalIssues: string[];
    recommendations: string[];
  };
}

class Layer52DocumentationSystemAgent extends EventEmitter {
  private layerId = 52;
  private layerName = 'Documentation System';
  private status: DocumentationSystemStatus;
  private fileIntegrityCheckInterval: NodeJS.Timer | null = null;
  private criticalFiles: string[] = [];

  constructor() {
    super();
    this.status = this.initializeStatus();
    this.loadCriticalFilesRegistry();
    this.generateSampleDocumentation();
    this.startFileIntegrityMonitoring();
    console.log(`[ESA Layer ${this.layerId}] ${this.layerName} Agent initialized`);
    console.log(`[ESA Layer ${this.layerId}] File Integrity Protection: ${this.status.fileIntegrity.enabled ? '✅ ACTIVE' : '❌ INACTIVE'}`);
  }

  private initializeStatus(): DocumentationSystemStatus {
    return {
      fileIntegrity: {
        enabled: false,
        lastCheck: null,
        totalCriticalFiles: 0,
        missingFiles: [],
        integrity: 100,
        alerts: []
      },
      apiDocumentation: {
        swagger: false,
        openapi: false,
        postman: false,
        insomnia: false,
        interactive: false,
        autoGenerated: false,
        coverage: 0,
        score: 0
      },
      userDocumentation: {
        userGuides: false,
        tutorials: false,
        gettingStarted: false,
        faq: false,
        troubleshooting: false,
        videoTutorials: false,
        score: 0
      },
      technicalDocumentation: {
        architecture: false,
        deployment: false,
        configuration: false,
        development: false,
        codeComments: false,
        changelog: false,
        score: 0
      },
      documentationMaintenance: {
        versionControl: false,
        automatedUpdates: false,
        reviewProcess: false,
        linkValidation: false,
        contentFreshness: 0,
        multiLanguage: false,
        score: 0
      },
      accessibility: {
        screenReaderFriendly: false,
        keyboardNavigation: false,
        highContrast: false,
        searchFunctionality: false,
        mobileOptimized: false,
        offlineAccess: false,
        score: 0
      },
      analytics: {
        usageTracking: false,
        popularContent: false,
        searchAnalytics: false,
        userFeedback: false,
        performanceMetrics: false,
        contentGaps: false,
        score: 0
      },
      files: [],
      apiDocs: {
        endpoints: 0,
        documented: 0,
        examples: 0,
        schemas: 0,
        interactivity: false,
        framework: ''
      },
      overallMetrics: {
        totalFiles: 0,
        totalWords: 0,
        averageCompleteness: 0,
        averageReadability: 0,
        lastUpdateAge: 0
      },
      compliance: {
        layerCompliance: 0,
        criticalIssues: [],
        recommendations: []
      }
    };
  }

  private generateSampleDocumentation(): void {
    const docTypes: DocumentationFile['type'][] = ['api', 'user-guide', 'technical', 'readme', 'changelog', 'tutorial'];
    const formats: DocumentationFile['format'][] = ['markdown', 'html', 'pdf', 'json', 'yaml'];

    this.status.files = [
      {
        path: '/README.md',
        type: 'readme',
        format: 'markdown',
        lastUpdated: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // 7 days ago
        wordCount: 2500,
        completeness: 85,
        readability: 78
      },
      {
        path: '/docs/api/openapi.yaml',
        type: 'api',
        format: 'yaml',
        lastUpdated: new Date(Date.now() - 14 * 24 * 60 * 60 * 1000), // 14 days ago
        wordCount: 5000,
        completeness: 70,
        readability: 65
      },
      {
        path: '/docs/user-guide/getting-started.md',
        type: 'user-guide',
        format: 'markdown',
        lastUpdated: new Date(Date.now() - 21 * 24 * 60 * 60 * 1000), // 21 days ago
        wordCount: 1800,
        completeness: 90,
        readability: 82
      },
      {
        path: '/docs/technical/architecture.md',
        type: 'technical',
        format: 'markdown',
        lastUpdated: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // 30 days ago
        wordCount: 3200,
        completeness: 75,
        readability: 70
      },
      {
        path: '/CHANGELOG.md',
        type: 'changelog',
        format: 'markdown',
        lastUpdated: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000), // 3 days ago
        wordCount: 1200,
        completeness: 95,
        readability: 85
      },
      {
        path: '/docs/tutorials/basic-setup.md',
        type: 'tutorial',
        format: 'markdown',
        lastUpdated: new Date(Date.now() - 45 * 24 * 60 * 60 * 1000), // 45 days ago
        wordCount: 2200,
        completeness: 80,
        readability: 88
      }
    ];

    // Generate API documentation metrics
    this.status.apiDocs = {
      endpoints: 35,
      documented: 24,
      examples: 18,
      schemas: 12,
      interactivity: this.hasInteractiveAPIDocs(),
      framework: this.detectAPIDocFramework()
    };
  }

  async auditLayer(): Promise<DocumentationSystemStatus> {
    console.log(`[ESA Layer ${this.layerId}] Starting comprehensive audit...`);

    // Evaluate API documentation
    this.evaluateAPIDocumentation();
    
    // Check user documentation
    this.checkUserDocumentation();
    
    // Assess technical documentation
    this.assessTechnicalDocumentation();
    
    // Evaluate documentation maintenance
    this.evaluateDocumentationMaintenance();
    
    // Check accessibility features
    this.checkAccessibilityFeatures();
    
    // Assess analytics and insights
    this.assessAnalytics();
    
    // Calculate overall metrics
    this.calculateOverallMetrics();
    
    // Calculate compliance score
    this.calculateComplianceScore();
    
    // Generate recommendations
    this.generateRecommendations();

    this.emit('auditCompleted', this.status);
    return this.status;
  }

  private evaluateAPIDocumentation(): void {
    // Check for API documentation frameworks
    const swagger = this.hasSwagger();
    const openapi = this.hasOpenAPI();
    const postman = this.hasPostmanCollection();
    const insomnia = this.hasInsomniaCollection();
    const interactive = this.hasInteractiveAPIDocs();
    const autoGenerated = this.hasAutoGeneratedAPIDocs();
    
    // Calculate API documentation coverage
    const coverage = this.status.apiDocs.endpoints > 0 ? 
      (this.status.apiDocs.documented / this.status.apiDocs.endpoints) * 100 : 0;

    // Calculate API documentation score
    let score = 0;
    if (swagger || openapi) score += 25;
    if (postman || insomnia) score += 15;
    if (interactive) score += 20;
    if (autoGenerated) score += 15;
    if (coverage > 80) score += 25;
    else if (coverage > 60) score += 20;
    else if (coverage > 40) score += 15;
    else if (coverage > 20) score += 10;

    this.status.apiDocumentation = {
      swagger,
      openapi,
      postman,
      insomnia,
      interactive,
      autoGenerated,
      coverage: Math.round(coverage),
      score: Math.min(100, score)
    };
  }

  private checkUserDocumentation(): void {
    const userGuides = this.hasUserGuides();
    const tutorials = this.hasTutorials();
    const gettingStarted = this.hasGettingStarted();
    const faq = this.hasFAQ();
    const troubleshooting = this.hasTroubleshooting();
    const videoTutorials = this.hasVideoTutorials();

    // Calculate user documentation score
    const features = [userGuides, tutorials, gettingStarted, faq, troubleshooting, videoTutorials];
    const score = (features.filter(Boolean).length / features.length) * 100;

    this.status.userDocumentation = {
      userGuides,
      tutorials,
      gettingStarted,
      faq,
      troubleshooting,
      videoTutorials,
      score: Math.round(score)
    };
  }

  private assessTechnicalDocumentation(): void {
    const architecture = this.hasArchitectureDoc();
    const deployment = this.hasDeploymentDoc();
    const configuration = this.hasConfigurationDoc();
    const development = this.hasDevelopmentDoc();
    const codeComments = this.hasCodeComments();
    const changelog = this.hasChangelog();

    // Calculate technical documentation score
    const features = [architecture, deployment, configuration, development, codeComments, changelog];
    const score = (features.filter(Boolean).length / features.length) * 100;

    this.status.technicalDocumentation = {
      architecture,
      deployment,
      configuration,
      development,
      codeComments,
      changelog,
      score: Math.round(score)
    };
  }

  private evaluateDocumentationMaintenance(): void {
    const versionControl = this.hasDocVersionControl();
    const automatedUpdates = this.hasAutomatedDocUpdates();
    const reviewProcess = this.hasDocReviewProcess();
    const linkValidation = this.hasLinkValidation();
    const multiLanguage = this.hasMultiLanguageSupport();
    
    // Calculate content freshness
    const contentFreshness = this.calculateContentFreshness();

    // Calculate maintenance score
    let score = 0;
    if (versionControl) score += 20;
    if (automatedUpdates) score += 20;
    if (reviewProcess) score += 15;
    if (linkValidation) score += 15;
    if (multiLanguage) score += 10;
    if (contentFreshness > 80) score += 20;
    else if (contentFreshness > 60) score += 15;
    else if (contentFreshness > 40) score += 10;

    this.status.documentationMaintenance = {
      versionControl,
      automatedUpdates,
      reviewProcess,
      linkValidation,
      contentFreshness: Math.round(contentFreshness),
      multiLanguage,
      score: Math.min(100, score)
    };
  }

  private checkAccessibilityFeatures(): void {
    const screenReaderFriendly = this.hasScreenReaderSupport();
    const keyboardNavigation = this.hasKeyboardNavigation();
    const highContrast = this.hasHighContrastSupport();
    const searchFunctionality = this.hasSearchFunctionality();
    const mobileOptimized = this.hasMobileOptimizedDocs();
    const offlineAccess = this.hasOfflineAccess();

    // Calculate accessibility score
    const features = [screenReaderFriendly, keyboardNavigation, highContrast, searchFunctionality, mobileOptimized, offlineAccess];
    const score = (features.filter(Boolean).length / features.length) * 100;

    this.status.accessibility = {
      screenReaderFriendly,
      keyboardNavigation,
      highContrast,
      searchFunctionality,
      mobileOptimized,
      offlineAccess,
      score: Math.round(score)
    };
  }

  private assessAnalytics(): void {
    const usageTracking = this.hasUsageTracking();
    const popularContent = this.hasPopularContentAnalysis();
    const searchAnalytics = this.hasSearchAnalytics();
    const userFeedback = this.hasUserFeedbackSystem();
    const performanceMetrics = this.hasPerformanceMetrics();
    const contentGaps = this.hasContentGapAnalysis();

    // Calculate analytics score
    const features = [usageTracking, popularContent, searchAnalytics, userFeedback, performanceMetrics, contentGaps];
    const score = (features.filter(Boolean).length / features.length) * 100;

    this.status.analytics = {
      usageTracking,
      popularContent,
      searchAnalytics,
      userFeedback,
      performanceMetrics,
      contentGaps,
      score: Math.round(score)
    };
  }

  private calculateOverallMetrics(): void {
    const files = this.status.files;
    
    const totalFiles = files.length;
    const totalWords = files.reduce((sum, f) => sum + f.wordCount, 0);
    const averageCompleteness = files.length > 0 ? 
      files.reduce((sum, f) => sum + f.completeness, 0) / files.length : 0;
    const averageReadability = files.length > 0 ? 
      files.reduce((sum, f) => sum + f.readability, 0) / files.length : 0;
    
    // Calculate average age of documentation
    const now = new Date();
    const averageAge = files.length > 0 ? 
      files.reduce((sum, f) => sum + (now.getTime() - f.lastUpdated.getTime()), 0) / files.length : 0;
    const lastUpdateAge = Math.round(averageAge / (1000 * 60 * 60 * 24)); // Convert to days

    this.status.overallMetrics = {
      totalFiles,
      totalWords,
      averageCompleteness: Math.round(averageCompleteness),
      averageReadability: Math.round(averageReadability),
      lastUpdateAge
    };
  }

  // Detection methods for documentation capabilities
  private hasSwagger(): boolean {
    return existsSync(join(process.cwd(), 'swagger.json')) ||
           existsSync(join(process.cwd(), 'swagger.yaml')) ||
           this.hasPackageDependency('swagger');
  }

  private hasOpenAPI(): boolean {
    return existsSync(join(process.cwd(), 'openapi.json')) ||
           existsSync(join(process.cwd(), 'openapi.yaml')) ||
           existsSync(join(process.cwd(), 'docs/api/openapi.yaml'));
  }

  private hasPostmanCollection(): boolean {
    return existsSync(join(process.cwd(), 'postman')) ||
           existsSync(join(process.cwd(), '*.postman_collection.json'));
  }

  private hasInsomniaCollection(): boolean {
    return existsSync(join(process.cwd(), 'insomnia')) ||
           existsSync(join(process.cwd(), '*.insomnia.json'));
  }

  private hasInteractiveAPIDocs(): boolean {
    return this.hasPackageDependency('swagger-ui') ||
           this.hasPackageDependency('redoc') ||
           existsSync(join(process.cwd(), 'docs/api/index.html'));
  }

  private hasAutoGeneratedAPIDocs(): boolean {
    return this.hasPackageDependency('swagger-jsdoc') ||
           this.hasPackageDependency('@apidevtools/swagger-jsdoc') ||
           existsSync(join(process.cwd(), 'scripts/generate-docs.js'));
  }

  private detectAPIDocFramework(): string {
    if (this.hasSwagger()) return 'Swagger';
    if (this.hasOpenAPI()) return 'OpenAPI';
    if (this.hasPackageDependency('swagger-ui-express')) return 'Swagger UI';
    return '';
  }

  private hasUserGuides(): boolean {
    return existsSync(join(process.cwd(), 'docs/user-guide')) ||
           existsSync(join(process.cwd(), 'user-guide.md'));
  }

  private hasTutorials(): boolean {
    return existsSync(join(process.cwd(), 'docs/tutorials')) ||
           existsSync(join(process.cwd(), 'tutorials'));
  }

  private hasGettingStarted(): boolean {
    return existsSync(join(process.cwd(), 'docs/getting-started.md')) ||
           existsSync(join(process.cwd(), 'GETTING_STARTED.md'));
  }

  private hasFAQ(): boolean {
    return existsSync(join(process.cwd(), 'docs/faq.md')) ||
           existsSync(join(process.cwd(), 'FAQ.md'));
  }

  private hasTroubleshooting(): boolean {
    return existsSync(join(process.cwd(), 'docs/troubleshooting.md')) ||
           existsSync(join(process.cwd(), 'TROUBLESHOOTING.md'));
  }

  private hasVideoTutorials(): boolean {
    return existsSync(join(process.cwd(), 'docs/videos')) ||
           this.hasFileContaining('docs', 'youtube.com') ||
           this.hasFileContaining('docs', 'vimeo.com');
  }

  private hasArchitectureDoc(): boolean {
    return existsSync(join(process.cwd(), 'docs/architecture.md')) ||
           existsSync(join(process.cwd(), 'ARCHITECTURE.md'));
  }

  private hasDeploymentDoc(): boolean {
    return existsSync(join(process.cwd(), 'docs/deployment.md')) ||
           existsSync(join(process.cwd(), 'DEPLOYMENT.md'));
  }

  private hasConfigurationDoc(): boolean {
    return existsSync(join(process.cwd(), 'docs/configuration.md')) ||
           existsSync(join(process.cwd(), 'CONFIG.md'));
  }

  private hasDevelopmentDoc(): boolean {
    return existsSync(join(process.cwd(), 'docs/development.md')) ||
           existsSync(join(process.cwd(), 'DEVELOPMENT.md')) ||
           existsSync(join(process.cwd(), 'CONTRIBUTING.md'));
  }

  private hasCodeComments(): boolean {
    return this.calculateCodeCommentCoverage() > 50;
  }

  private calculateCodeCommentCoverage(): number {
    // Simplified calculation - in real implementation would analyze source files
    return 65; // Simulated percentage
  }

  private hasChangelog(): boolean {
    return existsSync(join(process.cwd(), 'CHANGELOG.md')) ||
           existsSync(join(process.cwd(), 'HISTORY.md'));
  }

  private hasDocVersionControl(): boolean {
    return existsSync(join(process.cwd(), '.git')); // Docs are version controlled with code
  }

  private hasAutomatedDocUpdates(): boolean {
    return existsSync(join(process.cwd(), '.github/workflows/docs.yml')) ||
           existsSync(join(process.cwd(), 'scripts/update-docs.js'));
  }

  private hasDocReviewProcess(): boolean {
    return existsSync(join(process.cwd(), '.github/CODEOWNERS')) ||
           existsSync(join(process.cwd(), 'docs/REVIEW_PROCESS.md'));
  }

  private hasLinkValidation(): boolean {
    return existsSync(join(process.cwd(), '.github/workflows/link-check.yml')) ||
           this.hasPackageDependency('markdown-link-check');
  }

  private hasMultiLanguageSupport(): boolean {
    return existsSync(join(process.cwd(), 'docs/i18n')) ||
           existsSync(join(process.cwd(), 'docs/translations'));
  }

  private calculateContentFreshness(): number {
    const files = this.status.files;
    if (files.length === 0) return 0;

    const now = new Date();
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    const ninetyDaysAgo = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);

    let score = 0;
    files.forEach(file => {
      if (file.lastUpdated > thirtyDaysAgo) {
        score += 100;
      } else if (file.lastUpdated > ninetyDaysAgo) {
        score += 70;
      } else {
        score += 30;
      }
    });

    return score / files.length;
  }

  private hasScreenReaderSupport(): boolean {
    return this.hasFileContaining('docs', 'aria-') ||
           this.hasFileContaining('docs', 'role=');
  }

  private hasKeyboardNavigation(): boolean {
    return this.hasFileContaining('docs', 'tabindex') ||
           this.hasDocumentationSite();
  }

  private hasHighContrastSupport(): boolean {
    return this.hasFileContaining('docs', 'high-contrast') ||
           this.hasFileContaining('docs', 'prefers-contrast');
  }

  private hasSearchFunctionality(): boolean {
    return this.hasPackageDependency('docsearch') ||
           this.hasDocumentationSite();
  }

  private hasMobileOptimizedDocs(): boolean {
    return this.hasFileContaining('docs', 'viewport') ||
           this.hasDocumentationSite();
  }

  private hasOfflineAccess(): boolean {
    return existsSync(join(process.cwd(), 'docs/service-worker.js')) ||
           this.hasPackageDependency('workbox');
  }

  private hasDocumentationSite(): boolean {
    return this.hasPackageDependency('docusaurus') ||
           this.hasPackageDependency('vuepress') ||
           this.hasPackageDependency('gitbook');
  }

  private hasUsageTracking(): boolean {
    return this.hasFileContaining('docs', 'analytics') ||
           this.hasFileContaining('docs', 'google-analytics');
  }

  private hasPopularContentAnalysis(): boolean {
    return existsSync(join(process.cwd(), 'docs/analytics')) ||
           this.hasUsageTracking();
  }

  private hasSearchAnalytics(): boolean {
    return this.hasPackageDependency('docsearch') ||
           this.hasUsageTracking();
  }

  private hasUserFeedbackSystem(): boolean {
    return this.hasFileContaining('docs', 'feedback') ||
           existsSync(join(process.cwd(), 'docs/feedback.md'));
  }

  private hasPerformanceMetrics(): boolean {
    return existsSync(join(process.cwd(), 'docs/performance')) ||
           this.hasUsageTracking();
  }

  private hasContentGapAnalysis(): boolean {
    return existsSync(join(process.cwd(), 'docs/content-strategy.md')) ||
           existsSync(join(process.cwd(), 'content-analysis.json'));
  }

  // Utility methods
  private hasPackageDependency(packageName: string): boolean {
    try {
      const fs = require('fs');
      const packageJson = join(process.cwd(), 'package.json');
      if (!existsSync(packageJson)) return false;
      
      const content = fs.readFileSync(packageJson, 'utf8');
      const pkg = JSON.parse(content);
      
      const deps = { ...pkg.dependencies, ...pkg.devDependencies };
      return Object.keys(deps).some(dep => dep.includes(packageName));
    } catch {
      return false;
    }
  }

  private hasFileContaining(directory: string, searchTerm: string): boolean {
    try {
      const fs = require('fs');
      const dirPath = join(process.cwd(), directory);
      if (!existsSync(dirPath)) return false;
      
      const files = fs.readdirSync(dirPath);
      for (const file of files) {
        try {
          const filePath = join(dirPath, file);
          const stat = fs.statSync(filePath);
          
          if (stat.isFile() && (file.endsWith('.md') || file.endsWith('.html'))) {
            const content = fs.readFileSync(filePath, 'utf8');
            if (content.includes(searchTerm)) return true;
          } else if (stat.isDirectory()) {
            if (this.hasFileContaining(join(directory, file), searchTerm)) return true;
          }
        } catch {
          // Skip files that can't be read
        }
      }
      return false;
    } catch {
      return false;
    }
  }

  private calculateComplianceScore(): void {
    let score = 0;
    const maxScore = 100;

    // Weight each documentation category
    const apiWeight = 0.25; // 25%
    const userWeight = 0.20; // 20%
    const technicalWeight = 0.15; // 15%
    const maintenanceWeight = 0.15; // 15%
    const accessibilityWeight = 0.15; // 15%
    const analyticsWeight = 0.10; // 10%

    score += (this.status.apiDocumentation.score * apiWeight);
    score += (this.status.userDocumentation.score * userWeight);
    score += (this.status.technicalDocumentation.score * technicalWeight);
    score += (this.status.documentationMaintenance.score * maintenanceWeight);
    score += (this.status.accessibility.score * accessibilityWeight);
    score += (this.status.analytics.score * analyticsWeight);

    this.status.compliance.layerCompliance = Math.min(Math.round(score), maxScore);
  }

  private generateRecommendations(): void {
    const recommendations: string[] = [];
    const criticalIssues: string[] = [];

    // API documentation issues
    if (this.status.apiDocumentation.coverage < 60) {
      criticalIssues.push('Low API documentation coverage (<60%)');
      recommendations.push('Document all API endpoints with examples and schemas');
    }

    if (!this.status.apiDocumentation.swagger && !this.status.apiDocumentation.openapi) {
      criticalIssues.push('No API documentation standard implemented');
      recommendations.push('Implement OpenAPI/Swagger specification for APIs');
    }

    if (!this.status.apiDocumentation.interactive) {
      recommendations.push('Add interactive API documentation (Swagger UI, Redoc)');
    }

    if (!this.status.apiDocumentation.autoGenerated) {
      recommendations.push('Automate API documentation generation from code');
    }

    // User documentation issues
    if (!this.status.userDocumentation.gettingStarted) {
      criticalIssues.push('Missing getting started guide for users');
      recommendations.push('Create comprehensive getting started documentation');
    }

    if (!this.status.userDocumentation.userGuides) {
      recommendations.push('Develop detailed user guides for main features');
    }

    if (!this.status.userDocumentation.troubleshooting) {
      recommendations.push('Create troubleshooting guide for common issues');
    }

    if (this.status.userDocumentation.score < 50) {
      recommendations.push('Improve user-facing documentation coverage');
    }

    // Technical documentation issues
    if (!this.status.technicalDocumentation.architecture) {
      criticalIssues.push('Missing system architecture documentation');
      recommendations.push('Document system architecture and design decisions');
    }

    if (!this.status.technicalDocumentation.deployment) {
      recommendations.push('Create deployment and setup documentation');
    }

    if (!this.status.technicalDocumentation.changelog) {
      recommendations.push('Maintain a changelog for version tracking');
    }

    // Maintenance issues
    if (!this.status.documentationMaintenance.reviewProcess) {
      recommendations.push('Implement documentation review process');
    }

    if (!this.status.documentationMaintenance.automatedUpdates) {
      recommendations.push('Set up automated documentation updates');
    }

    if (this.status.documentationMaintenance.contentFreshness < 60) {
      criticalIssues.push('Documentation content is outdated');
      recommendations.push('Update outdated documentation regularly');
    }

    if (!this.status.documentationMaintenance.linkValidation) {
      recommendations.push('Implement automated link validation');
    }

    // Accessibility issues
    if (!this.status.accessibility.searchFunctionality) {
      recommendations.push('Add search functionality to documentation');
    }

    if (!this.status.accessibility.mobileOptimized) {
      recommendations.push('Optimize documentation for mobile devices');
    }

    if (this.status.accessibility.score < 50) {
      recommendations.push('Improve documentation accessibility features');
    }

    // Analytics issues
    if (!this.status.analytics.usageTracking) {
      recommendations.push('Implement documentation usage analytics');
    }

    if (!this.status.analytics.userFeedback) {
      recommendations.push('Add user feedback system for documentation');
    }

    // Overall metrics issues
    if (this.status.overallMetrics.averageCompleteness < 70) {
      recommendations.push('Improve completeness of existing documentation');
    }

    if (this.status.overallMetrics.averageReadability < 70) {
      recommendations.push('Improve documentation readability and clarity');
    }

    if (this.status.overallMetrics.lastUpdateAge > 60) {
      criticalIssues.push('Documentation has not been updated recently');
      recommendations.push('Establish regular documentation update schedule');
    }

    // General recommendations
    recommendations.push('Create documentation style guide and standards');
    recommendations.push('Implement automated documentation testing');
    recommendations.push('Set up documentation metrics and KPIs');
    recommendations.push('Consider documentation-as-code approach');

    this.status.compliance.criticalIssues = criticalIssues;
    this.status.compliance.recommendations = recommendations;
  }

  async getHumanReadableReport(): Promise<string> {
    const status = await this.auditLayer();
    
    return `
# ESA Layer ${this.layerId}: ${this.layerName} - Compliance Report

## Overall Compliance: ${status.compliance.layerCompliance}%

### API Documentation (Score: ${status.apiDocumentation.score}%)
- **Swagger/OpenAPI**: ${status.apiDocumentation.swagger || status.apiDocumentation.openapi ? '✅' : '❌'}
- **Postman Collections**: ${status.apiDocumentation.postman ? '✅' : '❌'}
- **Interactive Docs**: ${status.apiDocumentation.interactive ? '✅' : '❌'}
- **Auto-Generated**: ${status.apiDocumentation.autoGenerated ? '✅' : '❌'}
- **Coverage**: ${status.apiDocumentation.coverage}% (${status.apiDocs.documented}/${status.apiDocs.endpoints} endpoints)

### User Documentation (Score: ${status.userDocumentation.score}%)
- **User Guides**: ${status.userDocumentation.userGuides ? '✅' : '❌'}
- **Tutorials**: ${status.userDocumentation.tutorials ? '✅' : '❌'}
- **Getting Started**: ${status.userDocumentation.gettingStarted ? '✅' : '❌'}
- **FAQ**: ${status.userDocumentation.faq ? '✅' : '❌'}
- **Troubleshooting**: ${status.userDocumentation.troubleshooting ? '✅' : '❌'}
- **Video Tutorials**: ${status.userDocumentation.videoTutorials ? '✅' : '❌'}

### Technical Documentation (Score: ${status.technicalDocumentation.score}%)
- **Architecture**: ${status.technicalDocumentation.architecture ? '✅' : '❌'}
- **Deployment**: ${status.technicalDocumentation.deployment ? '✅' : '❌'}
- **Configuration**: ${status.technicalDocumentation.configuration ? '✅' : '❌'}
- **Development**: ${status.technicalDocumentation.development ? '✅' : '❌'}
- **Code Comments**: ${status.technicalDocumentation.codeComments ? '✅' : '❌'}
- **Changelog**: ${status.technicalDocumentation.changelog ? '✅' : '❌'}

### Documentation Maintenance (Score: ${status.documentationMaintenance.score}%)
- **Version Control**: ${status.documentationMaintenance.versionControl ? '✅' : '❌'}
- **Automated Updates**: ${status.documentationMaintenance.automatedUpdates ? '✅' : '❌'}
- **Review Process**: ${status.documentationMaintenance.reviewProcess ? '✅' : '❌'}
- **Link Validation**: ${status.documentationMaintenance.linkValidation ? '✅' : '❌'}
- **Multi-Language**: ${status.documentationMaintenance.multiLanguage ? '✅' : '❌'}
- **Content Freshness**: ${status.documentationMaintenance.contentFreshness}%

### Accessibility Features (Score: ${status.accessibility.score}%)
- **Screen Reader Friendly**: ${status.accessibility.screenReaderFriendly ? '✅' : '❌'}
- **Keyboard Navigation**: ${status.accessibility.keyboardNavigation ? '✅' : '❌'}
- **High Contrast**: ${status.accessibility.highContrast ? '✅' : '❌'}
- **Search Functionality**: ${status.accessibility.searchFunctionality ? '✅' : '❌'}
- **Mobile Optimized**: ${status.accessibility.mobileOptimized ? '✅' : '❌'}
- **Offline Access**: ${status.accessibility.offlineAccess ? '✅' : '❌'}

### Documentation Analytics (Score: ${status.analytics.score}%)
- **Usage Tracking**: ${status.analytics.usageTracking ? '✅' : '❌'}
- **Popular Content**: ${status.analytics.popularContent ? '✅' : '❌'}
- **Search Analytics**: ${status.analytics.searchAnalytics ? '✅' : '❌'}
- **User Feedback**: ${status.analytics.userFeedback ? '✅' : '❌'}
- **Performance Metrics**: ${status.analytics.performanceMetrics ? '✅' : '❌'}
- **Content Gap Analysis**: ${status.analytics.contentGaps ? '✅' : '❌'}

### Documentation Files Overview
${status.files.map(file => 
  `- **${file.path}** (${file.type}): ${file.wordCount.toLocaleString()} words, ${file.completeness}% complete, ${file.readability}% readable`
).join('\n')}

### Overall Metrics
- **Total Files**: ${status.overallMetrics.totalFiles}
- **Total Words**: ${status.overallMetrics.totalWords.toLocaleString()}
- **Average Completeness**: ${status.overallMetrics.averageCompleteness}%
- **Average Readability**: ${status.overallMetrics.averageReadability}%
- **Last Update**: ${status.overallMetrics.lastUpdateAge} days ago

### Critical Issues
${status.compliance.criticalIssues.map(issue => `- ⚠️ ${issue}`).join('\n')}

### Recommendations
${status.compliance.recommendations.map(rec => `- 📚 ${rec}`).join('\n')}

---
*Generated by Layer ${this.layerId} Agent - ${new Date().toISOString()}*
    `;
  }

  getStatus(): DocumentationSystemStatus {
    return { ...this.status };
  }

  getDocumentationFiles(): DocumentationFile[] {
    return [...this.status.files];
  }

  getAPIDocumentation(): APIDocumentation {
    return { ...this.status.apiDocs };
  }

  // ======================================
  // FILE INTEGRITY PROTECTION (Layer 3)
  // ======================================

  /**
   * Load critical files registry from scripts/critical-files.json
   */
  private loadCriticalFilesRegistry(): void {
    try {
      const registryPath = join(process.cwd(), 'scripts', 'critical-files.json');
      
      if (!existsSync(registryPath)) {
        console.warn(`[ESA Layer ${this.layerId}] ⚠️  Critical files registry not found at ${registryPath}`);
        console.warn(`[ESA Layer ${this.layerId}] ⚠️  File integrity monitoring will be disabled`);
        return;
      }

      const content = readFileSync(registryPath, 'utf-8');
      const registry = JSON.parse(content);

      // Flatten all files from all categories
      this.criticalFiles = [];
      for (const category of Object.values(registry.categories || {})) {
        if ((category as any).files && Array.isArray((category as any).files)) {
          this.criticalFiles.push(...(category as any).files);
        }
      }

      this.status.fileIntegrity.totalCriticalFiles = this.criticalFiles.length;
      this.status.fileIntegrity.enabled = this.criticalFiles.length > 0;

      console.log(`[ESA Layer ${this.layerId}] ✅ Loaded ${this.criticalFiles.length} critical files for monitoring`);
    } catch (error) {
      console.error(`[ESA Layer ${this.layerId}] ❌ Failed to load critical files registry:`, error);
    }
  }

  /**
   * Check all critical files exist
   */
  private async checkFileIntegrity(): Promise<void> {
    if (!this.status.fileIntegrity.enabled || this.criticalFiles.length === 0) {
      return;
    }

    const missing: string[] = [];

    for (const filePath of this.criticalFiles) {
      if (!existsSync(join(process.cwd(), filePath))) {
        missing.push(filePath);
      }
    }

    // Update status
    this.status.fileIntegrity.lastCheck = new Date();
    this.status.fileIntegrity.missingFiles = missing;
    this.status.fileIntegrity.integrity = this.criticalFiles.length > 0
      ? Math.round(((this.criticalFiles.length - missing.length) / this.criticalFiles.length) * 100)
      : 100;

    // Generate alerts for missing files
    if (missing.length > 0) {
      const alert = `🚨 FILE INTEGRITY BREACH: ${missing.length} critical files missing!`;
      this.status.fileIntegrity.alerts.push(alert);

      console.error(`[ESA Layer ${this.layerId}] ${alert}`);
      missing.forEach(file => {
        console.error(`[ESA Layer ${this.layerId}]   - MISSING: ${file}`);
      });

      // Emit event for other systems to react
      this.emit('fileIntegrityViolation', {
        missing,
        timestamp: new Date(),
        severity: 'critical'
      });
    } else if (this.status.fileIntegrity.alerts.length > 0) {
      // Clear alerts if all files recovered
      const recovery = '✅ All critical files restored';
      console.log(`[ESA Layer ${this.layerId}] ${recovery}`);
      this.status.fileIntegrity.alerts = [];
      
      this.emit('fileIntegrityRestored', {
        timestamp: new Date()
      });
    }
  }

  /**
   * Start periodic file integrity monitoring
   */
  private startFileIntegrityMonitoring(): void {
    if (!this.status.fileIntegrity.enabled) {
      return;
    }

    // Run initial check
    this.checkFileIntegrity();

    // Check every 60 seconds
    this.fileIntegrityCheckInterval = setInterval(() => {
      this.checkFileIntegrity();
    }, 60000);

    console.log(`[ESA Layer ${this.layerId}] 🔍 File integrity monitoring started (check interval: 60s)`);
  }

  /**
   * Stop file integrity monitoring (for cleanup)
   */
  public stopFileIntegrityMonitoring(): void {
    if (this.fileIntegrityCheckInterval) {
      clearInterval(this.fileIntegrityCheckInterval);
      this.fileIntegrityCheckInterval = null;
      console.log(`[ESA Layer ${this.layerId}] File integrity monitoring stopped`);
    }
  }

  /**
   * Get current file integrity status
   */
  public getFileIntegrityStatus(): FileIntegrityStatus {
    return this.status.fileIntegrity;
  }

  /**
   * Manual trigger for file integrity check (useful for testing)
   */
  public async runFileIntegrityCheck(): Promise<FileIntegrityStatus> {
    await this.checkFileIntegrity();
    return this.status.fileIntegrity;
  }
}

export const layer52Agent = new Layer52DocumentationSystemAgent();
export { Layer52DocumentationSystemAgent };