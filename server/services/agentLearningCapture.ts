/**
 * Agent Learning Capture System
 * ESA Layer 35 (AI Agent Management) + Layer 52 (Documentation)
 * 
 * Automatically captures agent learnings, patterns, and best practices
 * Generates implementation guides and efficiency playbooks
 */

import fs from 'fs/promises';
import path from 'path';

interface AgentLearning {
  agentId: number;
  agentName: string;
  category: 'success' | 'failure' | 'optimization' | 'pattern' | 'antipattern';
  title: string;
  description: string;
  context: string;
  solution?: string;
  codeExample?: string;
  timeSaved?: string;
  difficulty: 'easy' | 'medium' | 'hard';
  tags: string[];
  relatedAgents?: number[];
  esaLayers: number[];
  timestamp: string;
}

interface ImplementationGuide {
  issue: string;
  category: string;
  frequency: 'common' | 'occasional' | 'rare';
  severity: 'critical' | 'high' | 'medium' | 'low';
  solution: string;
  steps: string[];
  codeExample?: string;
  tools?: string[];
  estimatedTime: string;
  preventionTips: string[];
}

export class AgentLearningCaptureService {
  private learningsPath = 'docs/agent-learnings';
  private guidesPath = 'docs/implementation-guides';
  private playbookPath = 'docs/agent-efficiency-playbook.md';

  /**
   * Capture a learning from agent execution
   */
  async captureLearning(learning: AgentLearning): Promise<void> {
    await fs.mkdir(this.learningsPath, { recursive: true });
    
    const filename = `${learning.agentId}-${learning.category}-${Date.now()}.json`;
    const filepath = path.join(this.learningsPath, filename);
    
    await fs.writeFile(filepath, JSON.stringify(learning, null, 2));
    
    // Append to daily log for pattern detection
    const dailyLog = path.join(this.learningsPath, `daily-${new Date().toISOString().split('T')[0]}.json`);
    let dailyData: AgentLearning[] = [];
    
    try {
      const existing = await fs.readFile(dailyLog, 'utf-8');
      dailyData = JSON.parse(existing);
    } catch {
      // File doesn't exist yet
    }
    
    dailyData.push(learning);
    await fs.writeFile(dailyLog, JSON.stringify(dailyData, null, 2));
  }

  /**
   * Generate implementation guide from common issues
   */
  async generateImplementationGuide(guide: ImplementationGuide): Promise<void> {
    await fs.mkdir(this.guidesPath, { recursive: true });
    
    const markdown = `# ${guide.issue}

**Category:** ${guide.category}  
**Frequency:** ${guide.frequency}  
**Severity:** ${guide.severity}  
**Estimated Fix Time:** ${guide.estimatedTime}

## Problem Description

${guide.solution}

## Step-by-Step Solution

${guide.steps.map((step, i) => `${i + 1}. ${step}`).join('\n')}

${guide.codeExample ? `## Code Example

\`\`\`typescript
${guide.codeExample}
\`\`\`
` : ''}

${guide.tools && guide.tools.length > 0 ? `## Recommended Tools

${guide.tools.map(tool => `- ${tool}`).join('\n')}
` : ''}

## Prevention Tips

${guide.preventionTips.map(tip => `- ${tip}`).join('\n')}

---
*Auto-generated by Agent Learning Capture System*
`;

    const filename = guide.issue.toLowerCase().replace(/[^a-z0-9]+/g, '-') + '.md';
    const filepath = path.join(this.guidesPath, filename);
    
    await fs.writeFile(filepath, markdown);
  }

  /**
   * Analyze patterns and generate efficiency playbook
   */
  async generateEfficiencyPlaybook(): Promise<void> {
    // Read all learnings
    const files = await fs.readdir(this.learningsPath);
    const learnings: AgentLearning[] = [];
    
    for (const file of files) {
      if (file.endsWith('.json') && !file.startsWith('daily-')) {
        const content = await fs.readFile(path.join(this.learningsPath, file), 'utf-8');
        learnings.push(JSON.parse(content));
      }
    }

    // Analyze patterns
    const patterns = this.analyzePatterns(learnings);
    const antipatterns = learnings.filter(l => l.category === 'antipattern');
    const optimizations = learnings.filter(l => l.category === 'optimization');
    const successPatterns = learnings.filter(l => l.category === 'success');

    // Generate playbook
    const playbook = `# ESA Agent Efficiency Playbook
## Best Practices & Patterns from ${learnings.length} Agent Executions

**Generated:** ${new Date().toISOString()}  
**Total Learnings:** ${learnings.length}  
**Success Patterns:** ${successPatterns.length}  
**Optimizations Found:** ${optimizations.length}  
**Anti-patterns Identified:** ${antipatterns.length}

---

## üéØ Ultra-Micro Parallel Methodology

### Core Principle
**1 file + 1 operation + 1 output = 100% success**

${patterns.ultraMicro || 'Complex multi-step tasks in subagents lead to failures. Break into atomic operations.'}

---

## ‚úÖ Success Patterns (What Works)

${successPatterns.slice(0, 10).map((p, i) => `
### ${i + 1}. ${p.title}
- **Agent:** #${p.agentId} (${p.agentName})
- **Context:** ${p.context}
- **Time Saved:** ${p.timeSaved || 'N/A'}
${p.solution ? `- **Solution:** ${p.solution}` : ''}
${p.codeExample ? `
\`\`\`typescript
${p.codeExample}
\`\`\`
` : ''}
`).join('\n')}

---

## ‚ö° Optimization Discoveries

${optimizations.slice(0, 10).map((o, i) => `
### ${i + 1}. ${o.title}
- **Category:** ${o.category}
- **Impact:** ${o.timeSaved || 'Significant'}
- **ESA Layers:** ${o.esaLayers.join(', ')}
${o.description}
`).join('\n')}

---

## ‚ùå Anti-Patterns to Avoid

${antipatterns.slice(0, 10).map((a, i) => `
### ${i + 1}. ${a.title}
- **Problem:** ${a.description}
- **Why It Fails:** ${a.context}
${a.solution ? `- **Correct Approach:** ${a.solution}` : ''}
`).join('\n')}

---

## üîß Agent-Specific Best Practices

${this.generateAgentBestPractices(learnings)}

---

## üìä Performance Metrics

${this.generatePerformanceMetrics(learnings)}

---

## üöÄ Quick Reference Guide

### When to Use Subagents
- ‚úÖ Single file analysis (read/grep)
- ‚úÖ Atomic file edits (one change)
- ‚úÖ Research with clear output format
- ‚ùå Complex multi-step logic
- ‚ùå Shell command chains
- ‚ùå Dependencies between operations

### Parallel Execution Rules
- Execute independent tasks in parallel (3-6 max)
- Group by dependency (read ‚Üí analyze ‚Üí edit)
- Subagents for discovery, main agent for synthesis

### Documentation Patterns
- Capture learnings immediately after task
- Tag with ESA layers and related agents
- Include time saved and difficulty
- Code examples for reusable patterns

---

*This playbook is auto-generated and updated after each agent execution session.*
`;

    await fs.writeFile(this.playbookPath, playbook);
  }

  /**
   * Analyze patterns from learnings
   */
  private analyzePatterns(learnings: AgentLearning[]): Record<string, string> {
    const patterns: Record<string, string> = {};

    // Ultra-micro pattern detection
    const ultraMicroSuccesses = learnings.filter(l => 
      l.tags.includes('ultra-micro') && l.category === 'success'
    );
    
    if (ultraMicroSuccesses.length > 0) {
      patterns.ultraMicro = `Found ${ultraMicroSuccesses.length} successful ultra-micro executions with ${
        ultraMicroSuccesses.reduce((sum, l) => {
          const match = l.timeSaved?.match(/(\d+)/);
          return sum + (match ? parseInt(match[1]) : 0);
        }, 0)
      }% average time savings.`;
    }

    // Documentation agent leverage
    const docAgentUsage = learnings.filter(l => l.relatedAgents?.includes(11));
    if (docAgentUsage.length > 0) {
      patterns.docAgent = `Documentation agent (#11) used in ${docAgentUsage.length} cases for ${
        docAgentUsage.filter(l => l.category === 'success').length
      } successful parallel synthesis operations.`;
    }

    return patterns;
  }

  /**
   * Generate agent-specific best practices
   */
  private generateAgentBestPractices(learnings: AgentLearning[]): string {
    const agentGroups = learnings.reduce((acc, l) => {
      if (!acc[l.agentId]) acc[l.agentId] = [];
      acc[l.agentId].push(l);
      return acc;
    }, {} as Record<number, AgentLearning[]>);

    return Object.entries(agentGroups)
      .slice(0, 5)
      .map(([agentId, items]) => {
        const successRate = (items.filter(i => i.category === 'success').length / items.length * 100).toFixed(0);
        return `
### Agent #${agentId}: ${items[0].agentName}
- **Success Rate:** ${successRate}%
- **Total Executions:** ${items.length}
- **Key Learning:** ${items.find(i => i.category === 'success')?.title || 'In progress'}
`;
      }).join('\n');
  }

  /**
   * Generate performance metrics
   */
  private generatePerformanceMetrics(learnings: AgentLearning[]): string {
    const totalTimeSaved = learnings
      .filter(l => l.timeSaved)
      .reduce((sum, l) => {
        const match = l.timeSaved?.match(/(\d+)/);
        return sum + (match ? parseInt(match[1]) : 0);
      }, 0);

    return `
- **Total Time Saved:** ${totalTimeSaved}% vs sequential approach
- **Average Agent Execution:** ${(learnings.length / Math.max(learnings.filter(l => l.category === 'success').length, 1)).toFixed(1)} learnings per successful task
- **Most Efficient Pattern:** Ultra-micro parallel (10x speed improvement documented)
- **Fastest Agent:** ${this.findFastestAgent(learnings)}
`;
  }

  /**
   * Find fastest agent based on learnings
   */
  private findFastestAgent(learnings: AgentLearning[]): string {
    const agentTimes = learnings
      .filter(l => l.timeSaved)
      .reduce((acc, l) => {
        if (!acc[l.agentId]) acc[l.agentId] = { name: l.agentName, total: 0, count: 0 };
        const match = l.timeSaved?.match(/(\d+)/);
        if (match) {
          acc[l.agentId].total += parseInt(match[1]);
          acc[l.agentId].count++;
        }
        return acc;
      }, {} as Record<number, { name: string; total: number; count: number }>);

    const fastest = Object.entries(agentTimes)
      .map(([id, data]) => ({ id, name: data.name, avg: data.total / data.count }))
      .sort((a, b) => b.avg - a.avg)[0];

    return fastest ? `Agent #${fastest.id} (${fastest.name}) - ${fastest.avg.toFixed(0)}% avg improvement` : 'N/A';
  }

  /**
   * Quick capture methods for common scenarios
   */
  async captureSuccess(agentId: number, agentName: string, title: string, details: {
    description: string;
    solution?: string;
    timeSaved?: string;
    codeExample?: string;
    esaLayers: number[];
  }): Promise<void> {
    await this.captureLearning({
      agentId,
      agentName,
      category: 'success',
      title,
      description: details.description,
      context: 'Successful execution',
      solution: details.solution,
      codeExample: details.codeExample,
      timeSaved: details.timeSaved,
      difficulty: 'medium',
      tags: ['success', 'pattern'],
      esaLayers: details.esaLayers,
      timestamp: new Date().toISOString()
    });
  }

  async captureOptimization(agentId: number, agentName: string, title: string, details: {
    before: string;
    after: string;
    improvement: string;
    esaLayers: number[];
  }): Promise<void> {
    await this.captureLearning({
      agentId,
      agentName,
      category: 'optimization',
      title,
      description: `Before: ${details.before}\nAfter: ${details.after}`,
      context: 'Performance optimization discovered',
      solution: details.improvement,
      timeSaved: details.improvement,
      difficulty: 'medium',
      tags: ['optimization', 'performance'],
      esaLayers: details.esaLayers,
      timestamp: new Date().toISOString()
    });
  }

  async captureAntipattern(agentId: number, agentName: string, title: string, details: {
    problem: string;
    whyItFailed: string;
    correctApproach: string;
    esaLayers: number[];
  }): Promise<void> {
    await this.captureLearning({
      agentId,
      agentName,
      category: 'antipattern',
      title,
      description: details.problem,
      context: details.whyItFailed,
      solution: details.correctApproach,
      difficulty: 'hard',
      tags: ['antipattern', 'lesson'],
      esaLayers: details.esaLayers,
      timestamp: new Date().toISOString()
    });
  }
}

export const agentLearningCapture = new AgentLearningCaptureService();
