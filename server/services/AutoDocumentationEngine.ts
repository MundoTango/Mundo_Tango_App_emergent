import * as fs from 'fs/promises';
import * as path from 'path';
import { db } from '../db';
import { agentLearnings } from '../../shared/schema';
import { eq } from 'drizzle-orm';

interface AgentLearning {
  id: number;
  pattern: string;
  problem: string;
  solution: string;
  esaLayers: string[] | null;
  agentDomains: string[] | null;
  codeExample: string | null;
  confidence: string | null;
  successMetrics: any;
  discoveredBy: string | null;
  relatedPatterns: string[] | null;
  appliedTo: any;
  validatedAt: Date | null;
}

export class AutoDocumentationEngine {
  async onPatternSuccess(learning: AgentLearning) {
    if (!learning.confidence || parseFloat(learning.confidence) < 0.9) {
      console.log(`[Auto-Doc] Skipping low confidence pattern: ${learning.pattern}`);
      return;
    }

    const docPath = this.getDocPath(learning);
    const markdown = this.generateMarkdown(learning);
    const fileName = `${learning.pattern}-${Date.now()}.md`;
    const fullPath = path.join(process.cwd(), docPath, fileName);

    await fs.mkdir(path.join(process.cwd(), docPath), { recursive: true });
    await fs.writeFile(fullPath, markdown);

    await this.updateIndex(docPath, fileName, learning);

    await db
      .update(agentLearnings)
      .set({
        documentedAt: new Date(),
        documentationPath: `${docPath}/${fileName}`,
        updatedAt: new Date(),
      })
      .where(eq(agentLearnings.id, learning.id));

    console.log(`[Auto-Doc] Generated: ${docPath}/${fileName}`);
  }

  private generateMarkdown(learning: AgentLearning): string {
    const date = new Date().toISOString().split('T')[0];
    const confidence = learning.confidence ? (parseFloat(learning.confidence) * 100).toFixed(1) : 'N/A';
    
    return `# ${learning.pattern}

**Date:** ${date}  
**ESA Layers:** ${learning.esaLayers?.join(', ') || 'N/A'}  
**Agent Domains:** ${learning.agentDomains?.join(', ') || 'N/A'}  
**Confidence:** ${confidence}%  
**Discovered By:** ${learning.discoveredBy || 'Unknown'}

## Problem

${learning.problem}

## Solution

${learning.solution}

${learning.codeExample ? `## Code Example

\`\`\`typescript
${learning.codeExample}
\`\`\`` : ''}

## Success Metrics

${this.formatMetrics(learning.successMetrics)}

${learning.relatedPatterns && learning.relatedPatterns.length > 0 ? `## Related Patterns

${learning.relatedPatterns.map(p => `- [${p}](../learnings/${p}.md)`).join('\n')}` : ''}

${learning.appliedTo && Object.keys(learning.appliedTo).length > 0 ? `## Applied To

\`\`\`json
${JSON.stringify(learning.appliedTo, null, 2)}
\`\`\`` : ''}

---

*Auto-generated by ESA Agent Learning System on ${date}*
`;
  }

  private formatMetrics(metrics: any): string {
    if (!metrics || typeof metrics !== 'object') return 'No metrics available';
    
    return Object.entries(metrics)
      .map(([key, value]) => `- **${key}:** ${value}`)
      .join('\n');
  }

  private getDocPath(learning: AgentLearning): string {
    const layers = learning.esaLayers || [];
    
    if (layers.some(l => ['7', '14'].includes(l))) {
      return 'docs/pages/architecture';
    }
    
    if (layers.some(l => parseInt(l) >= 31 && parseInt(l) <= 46)) {
      return 'docs/pages/esa-agents';
    }
    
    if (learning.pattern.includes('aurora-tide')) {
      return 'docs/pages/design-systems';
    }
    
    return 'docs/pages/learnings';
  }

  private async updateIndex(docPath: string, fileName: string, learning: AgentLearning) {
    const indexPath = path.join(process.cwd(), docPath, 'index.md');
    
    try {
      let content = '';
      try {
        content = await fs.readFile(indexPath, 'utf-8');
      } catch {
        content = `# Learning Index\n\nAuto-generated documentation from ESA Agent Learning System.\n\n## Patterns\n\n`;
      }

      const entry = `- [${learning.pattern}](./${fileName}) - ${learning.problem.substring(0, 100)}... (Confidence: ${learning.confidence ? (parseFloat(learning.confidence) * 100).toFixed(1) : 'N/A'}%)\n`;
      
      if (!content.includes(learning.pattern)) {
        content += entry;
        await fs.writeFile(indexPath, content);
      }
    } catch (error) {
      console.error('[Auto-Doc] Failed to update index:', error);
    }
  }

  async reindexForAgents(filePath: string) {
    console.log(`[Auto-Doc] Triggering agent re-indexing for: ${filePath}`);
  }
}

export const autoDocEngine = new AutoDocumentationEngine();
