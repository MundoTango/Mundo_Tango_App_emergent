# single-queryclient-pattern

**Date:** 2025-10-12  
**ESA Layers:** 7, 14  
**Agent Domains:** infrastructure, frontend  
**Confidence:** 98.0%  
**Discovered By:** infrastructure

## Problem

Dual QueryClient initialization in EnhancedMemoriesRealtime caused cache corruption. Component created its own QueryClient instance instead of using the singleton from queryClient.ts, resulting in mutations updating one cache while queries read from another, causing perpetual stale data.

## Solution

Always import and use the singleton QueryClient from @lib/queryClient. Never instantiate new QueryClient() in components. Configure global defaults in one place (gcTime: 30min, staleTime: 0) and ensure all mutations/queries use the same instance. This guarantees cache consistency across all surfaces.

## Code Example

```typescript
// WRONG: Creating new QueryClient in component
import { QueryClient } from '@tanstack/react-query';
const queryClient = new QueryClient(); // ❌ Cache isolation!

// RIGHT: Use singleton
import { queryClient } from '@lib/queryClient'; // ✅ Shared cache

// Global configuration (queryClient.ts)
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 30, // 30 minutes
      staleTime: 0, // Always check for updates
    },
  },
});
```

## Success Metrics

- **dataConsistency:** guaranteed
- **cacheBugsEliminated:** 100%
- **developmentConfusion:** eliminated

## Related Patterns

- [segment-aware-query-matching](../learnings/segment-aware-query-matching.md)

## Applied To

```json
{
  "files": [
    "client/src/components/EnhancedMemoriesRealtime.tsx",
    "client/src/components/EventRSVPButton.tsx",
    "client/src/components/PostLikeComment.tsx"
  ],
  "components": [
    "EnhancedMemoriesRealtime",
    "EventRSVPButton",
    "PostLikeComment"
  ]
}
```

---

*Auto-generated by ESA Agent Learning System on 2025-10-12*
