# cross-surface-synchronization

**Date:** 2025-10-11  
**ESA Layers:** 7, 14, 22  
**Agent Domains:** infrastructure, frontend  
**Confidence:** 93.0%  
**Discovered By:** infrastructure

## Problem

Same data displayed on multiple surfaces (feed cards, detail pages, sidebars) would show inconsistent states after mutations. Updating one surface wouldn't reflect on others, causing confusion and requiring full page refreshes.

## Solution

Invalidate all query variants that contain the same data using predicate-based matching. After any mutation, find and invalidate all queries that include the affected entity, regardless of the query structure. This ensures feeds, detail pages, lists, and embedded views all update simultaneously with zero perceived latency.

## Code Example

```typescript
// Synchronize across all surfaces showing the same data
const invalidateEventQueries = (eventId: number) => {
  queryClient.invalidateQueries({
    predicate: (query) => {
      const key = query.queryKey as string[];
      // Match all queries containing this event
      return key.includes('/api/events') || 
             key.includes(`/api/events/${eventId}`) ||
             (key.includes('/api/posts') && query.state.data?.entityId === eventId);
    }
  });
};

// Usage after RSVP mutation
await invalidateEventQueries(eventId);
```

## Success Metrics

- **userReports:** zero inconsistency bugs
- **surfacesCovered:** 5+ (feed, details, map, sidebar, notifications)
- **surfaceSyncLatency:** <50ms

## Related Patterns

- [segment-aware-query-matching](../learnings/segment-aware-query-matching.md)
- [optimistic-update-preservation](../learnings/optimistic-update-preservation.md)

## Applied To

```json
{
  "files": [
    "client/src/hooks/useEventRSVP.ts",
    "client/src/hooks/usePostLike.ts",
    "client/src/hooks/useFriendRequest.ts"
  ],
  "components": [
    "useEventRSVP",
    "usePostLike",
    "useFriendRequest"
  ]
}
```

---

*Auto-generated by ESA Agent Learning System on 2025-10-11*
